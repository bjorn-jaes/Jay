# Jay

## Introduction

**Jay** is a small, C++17 extention for [Canary](https://github.com/djarek/canary) that implements
higher-layer [SEA J1939](https://en.wikipedia.org/wiki/SAE_J1939) protocol.

It its current state the library is inteded to be run on linux machines were in-cernel j1939 drivers are not included.
As was my case when working with Jetson Nano machines and J1939.

## Dependencies

**Jay** depends on [Canary](https://github.com/djarek/canary) as it provides the underlaying 
[CAN bus](https://en.wikipedia.org/wiki/CAN_bus) implementation. Additionaly [Boost-Ext SML](https://github.com/boost-ext/sml)
is used to implement a state machine for dynamic address managment.

Running tests currently requires [GTest](https://github.com/google/googletest), 
but I might change it to Boost.Core later to reduce the number of dependecies.

## Installation
**Jay** is header-only, so you only need to add the include directory to the
include paths in your build system. An `install` target is available in CMake
which will install the headers and a CMake `find_package` configuration script
for easy consumption in projects built with CMake:

```bash
mkdir build
cd build
cmake ..
make install
```

After installation, a project built with CMake can consume the library using
`find_package`:

```cmake
find_package(jay REQUIRED)
target_link_libraries(my_target PUBLIC jay::jay)
```

## Running tests
Tests require the existence of 2 virtual CAN interfaces - `vcan0` and `vcan1`,
which can be created with the following commands:

```
sudo ip link add dev vcan0 type vcan
sudo ip link set up vcan0
sudo ip link add dev vcan1 type vcan
sudo ip link set up vcan1
```
Use `sudo modprobe vcan` if the vcan drivers are not on.

Tests can be run using the standard `test` target generated by CMake:
```bash
mkdir build
cd build
cmake ..
make test
```

## Documentation
- Examples (TODO)
- [API Reference - entities](doc/generated/standardese_entities.md)
- [API Reference - files](doc/generated/standardese_files.md)

## Notes

This library might have some conflicts with the [Kernel J1939](https://www.kernel.org/doc/html/latest/networking/j1939.html)
implementation of linux. As a ECU address is used b the in-kernel system exclusivly. Some other information to note regarding
the in-kernel system is that the mapping of connected devices is not exposed through any api currently as far as i know.
Thought can-utils does include the j1939acd tool, so it can be used as code example or as default Address Claiming daemon.
The current implementation is on top of Raw CAN. In the future it would be nice if I could find some way of integrating the current
code with the linux J1939.